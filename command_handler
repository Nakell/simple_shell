#include "myshell.h"

/**
 * execute_command_args - this function execute a command with arguments
 * @command_line: the command line to execute
 */
void execute_command_args(char *command_line)
{
	pid_t pid;
	int status;
	char *full_path = NULL;
	char *path = getenv("PATH");
	char *token = strtok(path, ":");

	if (path == NULL)
	{
		fprintf(stderr, "Error: Path env not set.\n");
		return;
	}

	while (token != NULL)
	{
		full_path = malloc(strlen(token) + strlen(command) + 2);
		if (full_path == NULL)
		{
			perror("malloc");
			exit(EXIT_FAILURE);
		}
		strcpy(full_path, token);
		strcat(full_path, '/');
		strcat(full_path, command);



	pid = fork();

	if (pid == -1)
	{
		perror("fork");
		exit(EXIT_FAILURE);
	}
	else if (pid == 0)
	{
		if (access(full_path, X_OK) == 0)
		{
			execv(full_path, NULL);
			perror("execv");
			exit(EXIT_FAILURE);
		}
		exit(EXIT_SUCCESS);
	}
	else
	{
		free(full_path);
		waitpid(pid, &status, 0);
		if (WIFEXITED(status) && WEXITSTATUS(status) == 0)
		{
			break;
		}
	}
	token = strtok(NULL, ":");
	fprintf(stderr, "Command '%s' not found\n", command);
}

/**
 * contains_args - function checks if a command line contains spaces
 * (indicating arguments)
 * @command_line: the commadn line to be checked
 * REturn: 1 if arguments are found, otherwise 0
 */
int contains_args(const char *command_line)
{
	while (*command_line)
	{
		if (*command_line == ' ')
		{
			return(1);
		}
		command_line++;
	}
	return(0);
}
void execute_command_args_shell(void)
{
	char *line = NULL;
	size_t line_size = 0;

	while (1)
	{
		printf("$ ");
		fflush(stdout);
		if (getline(&line, &line_size, stdin) == -1)
		{
			free(line);
			break;
		}
		line[strcspn(line, "\n")] = '\0';

		if (contains_args(line))
		{
			char *token = strtok(line, " ");
			execute_command_args(token);
		}
		else
		{
			printf("Command '%s' not found\n", line);
		}
	}
	free(line);
}
